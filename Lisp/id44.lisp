(require "DEFINITIONS" "definitions.lisp")
(require "QUERY" "query.lisp")
(require "FRAGMENT" "fragment.lisp")
(require "ID8" "id8.lisp")

(provide "ID44")

(defun id44-recognize (l)
  (cond ((stringp l) (id44-recognize (coerce l 'list)))
        ((listp l) (id44-accept 'q0 l))
  )
)

(defun id44-accept (q l &optional (acc NIL))
  (cond ((null q) NIL) 
        ((null l) (if (and (id44-final q) (< (length acc) 45)) 
                      (list (list acc NIL) NIL NIL) NIL))
        ((char= (car l) #\() 
         (if (and (id44-final q) (< (length acc) 45)) 
             (let ((id8 (id8-recognize (cdr l))))
               (if (= (length id8) 3) 
                   (list (list acc (car id8)) 
                         (second id8) 
                         (third id8)) NIL)) NIL))

        ((char= (car l) #\?) 
         (if (and (id44-final q) (< (length acc) 45)) 
             (append (list (list acc NIL)) 
                     (query-recognize (cdr l)))
           NIL))

        ((char= (car l) #\#) 
         (if (and (id44-final q) (< (length acc) 45))
             (append (list (list acc NIL)) 
                     (list NIL) 
                     (fragment-recognize (cdr l)))
           NIL))

        (T (id44-accept (id44-delta q (car l))
                       (cdr l)
                       (append acc (cons (car l) NIL))
                       ))
        )
  )

(defun id44-final (q)
  (if (eql q 'q1) T)
)

(defun id44-delta (q x)
  (cond ((eql q 'q0) (if (alpha x) 'q1))
        ((eql q 'q1) (cond ((alphanum x) 'q1)
                           ((char= x #\.) 'q2)
                           ))
        ((eql q 'q2) (cond ((alphanum x) 'q1)
                           ((char= x #\.) 'q2)
                           ))
        )
  )